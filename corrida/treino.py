# Lara Popov Zambiasi Bazzi Oberderfer# Redes Neurais Convolucionaisimport copyimport matplotlibimport matplotlib.pyplot as plt  # para os plotsimport torchfrom torch.autograd import Variablefrom torch import optim, nnfrom model import Net, Net2from gera_lotes import get_lote# função treinodef treino(model, criterion, train_loader, test_loader, max_epochs=2000, learning_rate=1e-4):    lotes = {"treinar": train_loader, "validar": test_loader}    # imprimir modelo para ver    print(model)    # definindo o otimizador    optimizer = optim.SGD(model.parameters(), lr=learning_rate, momentum=0.3)    # optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)    # precisão no conjunto de treinamento    best_acc = 0    # armazenando dados para plot    custo_treino = []    custo_treino_val = []    acc = []    acc_val = []    for epoch in range(max_epochs):        print('Época {}/{}'.format(epoch, max_epochs - 1))        print('-' * 10)        # cada epoca tem fase de treinamento e validacao        for fase in ['treinar', 'validar']:            if fase == 'treinar':                model.train(True)  # modelo no modo treinamento            else:                model.train(False)  # modelo no modo avaliacao            running_loss = 0.0            running_corrects = 0            for lote in lotes[fase]:                # recebe dados de entrada                inputs, labels = lote                labels = labels.view(labels.size(0))                inputs, labels = Variable(inputs), Variable(labels)                # zerar os gradientes dos otimizadores                optimizer.zero_grad()                # previsão para treinamento e validação                outputs = model(inputs)                _, preds = torch.max(outputs.data, 1)                loss = criterion(outputs, labels)                # backward + optimize somente para fase treinamento                if fase == 'treinar':                    # calcula os pesos atualizados de todos os parâmetros do modelo                    loss.backward()                    # atualiza os parametros do otimizador                    optimizer.step()                # estatisticas                running_loss += loss.data.item() * inputs.size(0)                running_corrects += torch.sum(preds == labels.data)            epoch_loss = running_loss / len(lotes[fase])            epoch_acc = running_corrects / len(lotes[fase])            if fase == 'treinar':                custo_treino.append(epoch_loss)                acc.append(epoch_acc)            else:                custo_treino_val.append(epoch_loss)                acc_val.append(epoch_acc)            print('custo {}: {:.4f} Acuracia: {:.4f}'.format(                fase, epoch_loss, epoch_acc))            # ao final salva o modelo            if fase == 'validar' and epoch_acc > best_acc:                best_acc = epoch_acc                best_model_wts = copy.deepcopy(model.state_dict())                torch.save(best_model_wts, "treino11/treino11_%s.pt" % epoch)    print('Treinamento completo!!!')    print('Melhor acuracia: {:4f}'.format(best_acc))    # plot o custo ao longo do treinamento por epoca    fig = plt.figure(figsize=(20, 10))    plt.subplot(1, 2, 1)    plt.plot(custo_treino, label='Treino')    plt.plot(custo_treino_val, label='Validação')    plt.xlabel('Épocas', size = 15)    plt.ylabel('Custo', size = 15)    plt.xticks(size = 15)    plt.yticks(size=15)    plt.legend(prop = {'size': 15})    plt.title('Custo ao longo do treinamento por época')    plt.subplot(1, 2, 2)    plt.plot(acc, label='Treino')    plt.plot(acc_val, label='Validação')    plt.xlabel('Épocas', size = 15)    plt.ylabel('Acuracidade', size = 15)    plt.xticks(size=15)    plt.yticks(size=15)    plt.legend(prop = {'size': 15})    plt.title('Acuracidade ao longo do treinamento por época')    plt.tight_layout()    plt.show()if __name__ == '__main__':    num_classes = 3    model = Net2()    # caminhos para a pasta de imagens    train_path = "imagens"    test_path = "imagens"    # criação de um conjunto de validação    train_loader = get_lote(train_path, tamanho=32)    test_loader = get_lote(test_path, tamanho=32)    # função de custo, de perda    loss = nn.CrossEntropyLoss()    # chamando a funcao para treinar    treino(model, loss, train_loader, test_loader)